/*
您有一个神奇的背包，背包内有V个格子。
您所在的空间内有一些药，每个药会占用1或2个格子。
每天可以进行一次如下操作:
采摘一个药材放入背包中，若此时背包中格子已满，可以先将背包中的若干药材扔出去，至于扔多少以及扔几个，全都由您决定。当然您也可以选择不去进行采摘操作。
每一天结束前,神奇背包中的每个药材都会产生一个药丸。
注意，当天的药材如果不采摘，在第二天就会消失（当天药材仅限当天采摘)。
为了获得尽可能多的药丸，请您计算最终能获得的药丸数目最多是多少?


输入描述:
给定一个整数 V，接下来一行一个由1和2构成的字符串s表示药占用体积的情况。
其中1表示该药占用体积为1，2表示该药占用体积为2。
V <100000,[s| ≤100000
输出描述:
最多的药丸数目。
样例:
样例输入①
3
212
样例输出①
5

样例输入2
5
12112
样例输出2
14
样例输入3
6
112212
样例输出3
18
*/

/*题解思路
ans是结果;
cnt1是药材1的数量,cnt2是药材2的数量;
cnt1 + cnt2*2就表示背包里面已经占有的格子;
因为需要满足尽可能的多,所以只要背包没有装满就尽可能的装;
字符串s是输入的1和2;
s[i]就表示'1'或者'2';
所以:
s[i] = '2'时         cnt1 + cnt2*2 + 2<= V; cnt2++
				如果 cnt1 + cnt2*2 + 2> V 则装不下了;即背包还剩一个格子或者不剩;那今天就放弃采药,所以不管这个

s[i] = '1'时         cnt1 + cnt2*2 + 1<= v; cnt1++
				如果 cnt1 + cnt2*2 + 1> v ; cnt2-- cnt1++;那么只要背包里面有2(即cnt2>0)那就把2换了;因为产生药丸数量一样;且多出格子
				
				每天结束  ans = cnt1+cnt2;
*/

#include <stdio.h>
int main()
{
	long long cnt1 = 0, cnt2 = 0, ans = 0, V = 0;
	scanf("%d", &V);
	char s[100000];
	scanf("%s", s);
	int i = 0;
	for (i = 0; i < V; i++)
	{
		if (s[i] == '2')
		{
			if ((cnt1 + cnt2 * 2 + 2) <= V)
				cnt2++;
		}
		else
		{
			if ((cnt1 + cnt2 * 2 + 1) <= V)
			{
				cnt1++;
			}
			else if (cnt2 > 0)
			{
				cnt1++;
				cnt2--;
			}
		}
		ans += cnt1 + cnt2;
	}
	printf("%lld", ans);
	return 0;
}
